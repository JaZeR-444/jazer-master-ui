<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Pixel Grid Cursor Highlight - JaZeR</title>
  <link rel="stylesheet" href="../../../jazer-brand.css">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: var(--font-body);
      background: linear-gradient(135deg, #0a0a0f 0%, #1a0b2e 100%);
      color: var(--jazer-cyan);
      cursor: none;
      overflow: hidden;
      height: 100vh;
    }

    .back-button {
      position: fixed;
      top: 20px;
      left: 20px;
      color: var(--jazer-cyan);
      text-decoration: none;
      font-size: 1.2rem;
      z-index: 1000;
      padding: 10px 20px;
      border: 2px solid var(--jazer-cyan);
      border-radius: 8px;
      background: rgba(0, 242, 234, 0.1);
      transition: all 0.3s ease;
    }

    .back-button:hover {
      background: rgba(0, 242, 234, 0.2);
      transform: translateX(-5px);
    }

    .info {
      position: fixed;
      top: 100px;
      left: 50%;
      transform: translateX(-50%);
      text-align: center;
      z-index: 10;
      background: rgba(0, 242, 234, 0.1);
      padding: 30px 50px;
      border: 2px solid var(--jazer-cyan);
      border-radius: 12px;
      backdrop-filter: blur(10px);
    }

    .info h1 {
      font-family: var(--font-primary);
      font-size: 2.5rem;
      background: var(--gradient-text);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      margin-bottom: 10px;
    }

    .info p {
      color: var(--jazer-purple);
      font-size: 1.1rem;
    }

    #canvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 1;
    }

    .cursor {
      position: fixed;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      pointer-events: none;
      z-index: 9999;
      transform: translate(-50%, -50%);
      background: var(--jazer-cyan);
      box-shadow: 0 0 20px var(--jazer-cyan);
    }

    @media (max-width: 768px) {
      .info {
        width: 90%;
        padding: 20px;
      }

      .info h1 {
        font-size: 1.8rem;
      }

      .info p {
        font-size: 0.9rem;
      }
    }
  </style>
</head>
<body>
  <a href="index.html" class="back-button">‚Üê Back to Gallery</a>
  
  <div class="info">
    <h1>Pixel Grid Cursor Highlight</h1>
    <p>Move your cursor to see the pixel grid light up around you</p>
  </div>

  <canvas id="canvas"></canvas>
  <div class="cursor" id="cursor"></div>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const cursor = document.getElementById('cursor');

    // Set canvas size
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    // Grid settings
    const cellSize = 20;
    const cols = Math.ceil(canvas.width / cellSize);
    const rows = Math.ceil(canvas.height / cellSize);

    // Create grid array
    const grid = [];
    for (let i = 0; i < rows; i++) {
      grid[i] = [];
      for (let j = 0; j < cols; j++) {
        grid[i][j] = {
          x: j * cellSize,
          y: i * cellSize,
          brightness: 0,
          targetBrightness: 0
        };
      }
    }

    let mouseX = canvas.width / 2;
    let mouseY = canvas.height / 2;

    // Track mouse movement
    document.addEventListener('mousemove', (e) => {
      mouseX = e.clientX;
      mouseY = e.clientY;
      cursor.style.left = mouseX + 'px';
      cursor.style.top = mouseY + 'px';
    });

    // Color functions
    function hslToRgb(h, s, l) {
      const c = (1 - Math.abs(2 * l - 1)) * s;
      const x = c * (1 - Math.abs((h / 60) % 2 - 1));
      const m = l - c / 2;
      
      let r, g, b;
      if (h < 60) { r = c; g = x; b = 0; }
      else if (h < 120) { r = x; g = c; b = 0; }
      else if (h < 180) { r = 0; g = c; b = x; }
      else if (h < 240) { r = 0; g = x; b = c; }
      else if (h < 300) { r = x; g = 0; b = c; }
      else { r = c; g = 0; b = x; }
      
      return {
        r: Math.round((r + m) * 255),
        g: Math.round((g + m) * 255),
        b: Math.round((b + m) * 255)
      };
    }

    // Animation loop
    let time = 0;
    function animate() {
      time += 0.02;
      
      // Clear canvas
      ctx.fillStyle = '#0a0a0f';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Update and draw grid
      for (let i = 0; i < rows; i++) {
        for (let j = 0; j < cols; j++) {
          const cell = grid[i][j];
          
          // Calculate distance from cursor
          const dx = cell.x + cellSize / 2 - mouseX;
          const dy = cell.y + cellSize / 2 - mouseY;
          const distance = Math.sqrt(dx * dx + dy * dy);
          
          // Calculate target brightness based on distance
          const maxDistance = 200;
          if (distance < maxDistance) {
            const proximity = 1 - (distance / maxDistance);
            cell.targetBrightness = proximity * proximity;
          } else {
            cell.targetBrightness = 0;
          }
          
          // Smooth brightness transition
          cell.brightness += (cell.targetBrightness - cell.brightness) * 0.15;
          
          // Draw cell if bright enough
          if (cell.brightness > 0.05) {
            // Calculate color based on position and time
            const angle = Math.atan2(dy, dx);
            const hue = ((angle * 180 / Math.PI) + 180 + time * 10) % 360;
            const color = hslToRgb(hue, 0.8, 0.5);
            
            // Draw cell glow
            ctx.fillStyle = `rgba(${color.r}, ${color.g}, ${color.b}, ${cell.brightness * 0.3})`;
            ctx.fillRect(cell.x - 2, cell.y - 2, cellSize + 4, cellSize + 4);
            
            // Draw cell
            ctx.fillStyle = `rgba(${color.r}, ${color.g}, ${color.b}, ${cell.brightness * 0.8})`;
            ctx.fillRect(cell.x, cell.y, cellSize, cellSize);
            
            // Draw cell border
            ctx.strokeStyle = `rgba(${color.r}, ${color.g}, ${color.b}, ${cell.brightness})`;
            ctx.lineWidth = 2;
            ctx.strokeRect(cell.x, cell.y, cellSize, cellSize);
            
            // Draw inner glow
            const gradient = ctx.createRadialGradient(
              cell.x + cellSize / 2, 
              cell.y + cellSize / 2, 
              0,
              cell.x + cellSize / 2, 
              cell.y + cellSize / 2, 
              cellSize
            );
            gradient.addColorStop(0, `rgba(${color.r}, ${color.g}, ${color.b}, ${cell.brightness * 0.5})`);
            gradient.addColorStop(1, 'transparent');
            ctx.fillStyle = gradient;
            ctx.fillRect(cell.x, cell.y, cellSize, cellSize);
          }
        }
      }

      // Draw cursor highlight
      const highlightGradient = ctx.createRadialGradient(mouseX, mouseY, 0, mouseX, mouseY, 150);
      highlightGradient.addColorStop(0, 'rgba(0, 242, 234, 0.2)');
      highlightGradient.addColorStop(0.5, 'rgba(147, 51, 234, 0.1)');
      highlightGradient.addColorStop(1, 'transparent');
      ctx.fillStyle = highlightGradient;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      requestAnimationFrame(animate);
    }

    animate();

    // Handle window resize
    window.addEventListener('resize', () => {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      
      // Rebuild grid
      const newCols = Math.ceil(canvas.width / cellSize);
      const newRows = Math.ceil(canvas.height / cellSize);
      
      grid.length = 0;
      for (let i = 0; i < newRows; i++) {
        grid[i] = [];
        for (let j = 0; j < newCols; j++) {
          grid[i][j] = {
            x: j * cellSize,
            y: i * cellSize,
            brightness: 0,
            targetBrightness: 0
          };
        }
      }
    });

    // Hide cursor when leaving window
    document.addEventListener('mouseleave', () => {
      cursor.style.opacity = '0';
    });

    document.addEventListener('mouseenter', () => {
      cursor.style.opacity = '1';
    });
  </script>
</body>
</html>