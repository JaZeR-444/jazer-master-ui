<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ambient Pad Wash</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #000;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: Arial, sans-serif;
        }
        
        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }
        
        .info {
            position: relative;
            z-index: 2;
            color: #a0f0ff;
            text-align: center;
            text-shadow: 0 0 10px rgba(160, 240, 255, 0.7);
        }
    </style>
</head>
<body>
    <div class="info">
        <h1>Ambient Pad Wash</h1>
        <p>Soothing ambient pad with evolving textures</p>
    </div>
    
    <canvas id="ambientCanvas"></canvas>
    
    <script>
        const canvas = document.getElementById('ambientCanvas');
        const ctx = canvas.getContext('2d');
        
        // Set canvas to full window size
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();
        
        // Ambient pad layer class
        class AmbientLayer {
            constructor(colorHue, speed, size) {
                this.colorHue = colorHue;
                this.speed = speed;
                this.size = size;
                this.offsetX = 0;
                this.offsetY = 0;
                this.noiseScale = 0.01;
                
                // Create offscreen canvas for the layer
                this.offscreenCanvas = document.createElement('canvas');
                this.offscreenCanvas.width = canvas.width;
                this.offscreenCanvas.height = canvas.height;
                this.offscreenCtx = this.offscreenCanvas.getContext('2d');
            }
            
            update() {
                // Update offset for movement
                const time = Date.now() * 0.0005;
                this.offsetX = Math.sin(time * this.speed) * 100;
                this.offsetY = Math.cos(time * this.speed * 0.7) * 70;
                
                // Create gradient for the layer
                const gradient = this.offscreenCtx.createLinearGradient(0, 0, canvas.width, canvas.height);
                gradient.addColorStop(0, `hsla(${this.colorHue}, 80%, 70%, 0.2)`);
                gradient.addColorStop(0.5, `hsla(${this.colorHue + 30}, 70%, 60%, 0.15)`);
                gradient.addColorStop(1, `hsla(${this.colorHue + 60}, 60%, 50%, 0.1)`);
                
                this.offscreenCtx.fillStyle = gradient;
                this.offscreenCtx.fillRect(0, 0, this.offscreenCanvas.width, this.offscreenCanvas.height);
                
                // Add subtle noise for texture
                this.addNoise();
            }
            
            addNoise() {
                const imageData = this.offscreenCtx.getImageData(0, 0, this.offscreenCanvas.width, this.offscreenCanvas.height);
                const data = imageData.data;
                
                for (let y = 0; y < this.offscreenCanvas.height; y += 2) {
                    for (let x = 0; x < this.offscreenCanvas.width; x += 2) {
                        const index = (y * this.offscreenCanvas.width + x) * 4;
                        
                        // Add subtle noise
                        const noise = Math.random() * 0.1 - 0.05;
                        data[index] = Math.min(255, Math.max(0, data[index] + noise * 255));       // R
                        data[index + 1] = Math.min(255, Math.max(0, data[index + 1] + noise * 255)); // G
                        data[index + 2] = Math.min(255, Math.max(0, data[index + 2] + noise * 255)); // B
                    }
                }
                
                this.offscreenCtx.putImageData(imageData, 0, 0);
            }
            
            draw() {
                // Draw the offscreen canvas to the main canvas
                ctx.drawImage(this.offscreenCanvas, 0, 0);
            }
        }
        
        // Create ambient layers
        const ambientLayers = [
            new AmbientLayer(200, 0.1, 50), // Blue range
            new AmbientLayer(240, 0.07, 70), // Indigo range
            new AmbientLayer(270, 0.05, 100) // Purple range
        ];
        
        // Ambient particles
        class AmbientParticle {
            constructor() {
                this.x = Math.random() * canvas.width;
                this.y = Math.random() * canvas.height;
                
                // Movement properties
                this.vx = (Math.random() - 0.5) * 0.05;
                this.vy = (Math.random() - 0.5) * 0.05;
                
                // Visual properties
                this.size = 1 + Math.random() * 3;
                this.originalSize = this.size;
                
                // Color properties
                this.hue = 200 + Math.random() * 100; // Blue to purple range
                this.saturation = 40 + Math.random() * 20;
                this.lightness = 70 + Math.random() * 20;
                
                // Pulsation properties
                this.pulseSpeed = 0.005 + Math.random() * 0.015;
                this.pulsePhase = Math.random() * Math.PI * 2;
            }
            
            update() {
                // Slow movement
                this.x += this.vx;
                this.y += this.vy;
                
                // Boundary wrap-around
                if (this.x > canvas.width) this.x = 0;
                if (this.x < 0) this.x = canvas.width;
                if (this.y > canvas.height) this.y = 0;
                if (this.y < 0) this.y = canvas.height;
                
                // Pulsate size
                const time = Date.now() * 0.001;
                this.size = this.originalSize * (0.8 + 0.2 * Math.sin(time * this.pulseSpeed + this.pulsePhase));
            }
            
            draw() {
                // Create radial gradient for the particle
                const gradient = ctx.createRadialGradient(
                    this.x, this.y, 0,
                    this.x, this.y, this.size * 4
                );
                
                gradient.addColorStop(0, `hsla(${this.hue}, ${this.saturation}%, ${this.lightness}%, 0.8)`);
                gradient.addColorStop(0.7, `hsla(${this.hue}, ${this.saturation * 0.7}%, ${this.lightness * 0.7}%, 0.4)`);
                gradient.addColorStop(1, `hsla(${this.hue}, ${this.saturation * 0.5}%, ${this.lightness * 0.5}%, 0)`);
                
                ctx.fillStyle = gradient;
                
                // Draw the particle
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        // Create ambient particles
        const ambientParticles = [];
        const particleCount = 50;
        
        for (let i = 0; i < particleCount; i++) {
            ambientParticles.push(new AmbientParticle());
        }
        
        // Draw light rays
        function drawLightRays() {
            const time = Date.now() * 0.0003;
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            
            for (let i = 0; i < 12; i++) {
                const angle = (i / 12) * Math.PI * 2 + time;
                const length = Math.min(canvas.width, canvas.height) * 0.8;
                
                const x1 = centerX + Math.cos(angle) * 20;
                const y1 = centerY + Math.sin(angle) * 20;
                const x2 = centerX + Math.cos(angle) * length;
                const y2 = centerY + Math.sin(angle) * length;
                
                const gradient = ctx.createLinearGradient(x1, y1, x2, y2);
                gradient.addColorStop(0, `hsla(240, 100%, 80%, 0.05)`);
                gradient.addColorStop(0.3, `hsla(270, 100%, 70%, 0.03)`);
                gradient.addColorStop(1, `hsla(300, 100%, 60%, 0)`);
                
                ctx.strokeStyle = gradient;
                ctx.lineWidth = 15 + Math.sin(time * 2 + i) * 5;
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.stroke();
            }
        }
        
        // Draw ambient clouds
        function drawAmbientClouds() {
            const time = Date.now() * 0.0002;
            
            for (let i = 0; i < 5; i++) {
                const x = (canvas.width / 5) * i + Math.sin(time + i) * 100;
                const y = canvas.height / 2 + Math.cos(time * 0.7 + i) * 80;
                
                const gradient = ctx.createRadialGradient(
                    x, y, 0,
                    x, y, 200 + Math.sin(time * 0.5 + i) * 50
                );
                
                gradient.addColorStop(0, `hsla(240 + ${i * 10}, 50%, 70%, 0.05)`);
                gradient.addColorStop(1, `hsla(260 + ${i * 10}, 40%, 50%, 0)`);
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(x, y, 200 + Math.sin(time * 0.5 + i) * 50, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        // Animation loop
        function animate() {
            // Clear with fade effect
            ctx.fillStyle = 'rgba(5, 5, 20, 0.05)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Update and draw ambient layers
            ambientLayers.forEach(layer => {
                layer.update();
                layer.draw();
            });
            
            // Draw light rays
            drawLightRays();
            
            // Draw ambient clouds
            drawAmbientClouds();
            
            // Update and draw particles
            ambientParticles.forEach(particle => {
                particle.update();
                particle.draw();
            });
            
            requestAnimationFrame(animate);
        }
        
        animate();
    </script>
</body>
</html>