<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rhythmic Audio Particles</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #000;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: Arial, sans-serif;
        }
        
        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }
        
        .info {
            position: relative;
            z-index: 2;
            color: white;
            text-align: center;
            text-shadow: 0 0 10px rgba(0,0,0,0.7);
        }
    </style>
</head>
<body>
    <div class="info">
        <h1>Rhythmic Audio Particles</h1>
        <p>Particles that move to the rhythm of simulated music</p>
    </div>
    
    <canvas id="audioParticlesCanvas"></canvas>
    
    <script>
        const canvas = document.getElementById('audioParticlesCanvas');
        const ctx = canvas.getContext('2d');
        
        // Set canvas to full window size
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();
        
        // Rhythmic Audio Particle class
        class AudioParticle {
            constructor() {
                // Start particles in the center
                this.x = canvas.width / 2;
                this.y = canvas.height / 2;
                
                // Physics properties
                this.vx = 0;
                this.vy = 0;
                this.ax = 0;
                this.ay = 0;
                
                // Visual properties
                this.size = 2 + Math.random() * 4;
                this.originalSize = this.size;
                
                // Color based on frequency range (bass, mid, treble)
                const range = Math.random();
                if (range < 0.33) {
                    // Bass (red-orange)
                    this.hue = 0 + Math.random() * 20;
                } else if (range < 0.66) {
                    // Mids (green-yellow)
                    this.hue = 60 + Math.random() * 20;
                } else {
                    // Treble (blue-purple)
                    this.hue = 240 + Math.random() * 60;
                }
                
                this.saturation = 80 + Math.random() * 20;
                this.lightness = 60 + Math.random() * 30;
                this.alpha = 0.3 + Math.random() * 0.7;
                
                // Rhythm properties
                this.beatSensitivity = 0.3 + Math.random() * 0.7; // How much it responds to beats
                this.frequency = 0.5 + Math.random() * 2.0; // Movement frequency
                this.phase = Math.random() * Math.PI * 2;
                
                // Lifetime properties
                this.maxLifetime = 100 + Math.random() * 100;
                this.lifetime = this.maxLifetime;
                
                // Audio response properties
                this.baseDistance = 20 + Math.random() * 100; // Base distance from center
                this.pulseFactor = 1 + Math.random() * 3; // How much it amplifies with audio
                this.rhythmPhase = Math.random() * Math.PI * 2;
            }
            
            update() {
                const time = Date.now() * 0.001;
                
                // Simulate audio input with rhythmic pulses
                const bassBeat = Math.sin(time * 0.5) > 0.8 ? 2 : 1; // Every 2 seconds
                const snareBeat = Math.sin(time * 1.3) > 0.9 ? 1.8 : 1; // Faster beat
                const hiHatBeat = Math.sin(time * 2.7) > 0.95 ? 1.5 : 1; // Fastest beat
                
                // Combined audio response
                const audioResponse = bassBeat * snareBeat * hiHatBeat;
                
                // Calculate target position based on audio
                const targetAngle = time * this.frequency + this.phase + this.rhythmPhase;
                const targetDistance = this.baseDistance * audioResponse * this.pulseFactor * this.beatSensitivity;
                
                const targetX = canvas.width / 2 + Math.cos(targetAngle) * targetDistance;
                const targetY = canvas.height / 2 + Math.sin(targetAngle) * targetDistance;
                
                // Apply forces to move toward target
                this.ax = (targetX - this.x) * 0.05;
                this.ay = (targetY - this.y) * 0.05;
                
                // Apply acceleration
                this.vx += this.ax;
                this.vy += this.ay;
                
                // Apply damping to prevent oscillation
                this.vx *= 0.95;
                this.vy *= 0.95;
                
                // Update position
                this.x += this.vx;
                this.y += this.vy;
                
                // Update size based on audio intensity
                this.size = this.originalSize * audioResponse * this.beatSensitivity;
                
                // Decrease lifetime
                this.lifetime--;
                
                // Pulsate based on rhythm
                const rhythmPulse = Math.sin(time * 3 + this.rhythmPhase) * 0.2 + 1;
                this.size *= rhythmPulse;
            }
            
            draw() {
                // Create radial gradient for the particle
                const gradient = ctx.createRadialGradient(
                    this.x, this.y, 0,
                    this.x, this.y, this.size * 4
                );
                
                gradient.addColorStop(0, `hsla(${this.hue}, ${this.saturation}%, ${this.lightness}%, ${this.alpha})`);
                gradient.addColorStop(0.5, `hsla(${this.hue}, ${this.saturation * 0.8}%, ${this.lightness * 0.7}%, ${this.alpha * 0.7})`);
                gradient.addColorStop(1, `hsla(${this.hue}, ${this.saturation * 0.6}%, ${this.lightness * 0.5}%, 0)`);
                
                ctx.fillStyle = gradient;
                
                // Draw particle
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw motion trail if moving fast
                if (Math.sqrt(this.vx * this.vx + this.vy * this.vy) > 1) {
                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y);
                    ctx.lineTo(this.x - this.vx * 3, this.y - this.vy * 3);
                    ctx.strokeStyle = `hsla(${this.hue}, ${this.saturation}%, ${this.lightness}%, ${this.alpha * 0.5})`;
                    ctx.lineWidth = 1;
                    ctx.stroke();
                }
            }
            
            isDead() {
                return this.lifetime <= 0;
            }
        }
        
        // Audio particles system
        class AudioParticleSystem {
            constructor() {
                this.particles = [];
                this.particleSpawnRate = 3; // Particles per frame
            }
            
            update() {
                // Spawn new particles
                for (let i = 0; i < this.particleSpawnRate; i++) {
                    if (Math.random() < 0.4) { // Not every frame
                        this.particles.push(new AudioParticle());
                    }
                }
                
                // Update existing particles
                for (let i = this.particles.length - 1; i >= 0; i--) {
                    this.particles[i].update();
                    
                    // Remove dead particles
                    if (this.particles[i].isDead()) {
                        this.particles.splice(i, 1);
                    }
                }
                
                // Occasionally change spawn rate for rhythmic variation
                if (Math.random() < 0.01) {
                    this.particleSpawnRate = 2 + Math.random() * 4;
                }
            }
            
            draw() {
                // Draw all particles
                this.particles.forEach(particle => {
                    particle.draw();
                });
            }
        }
        
        // Create the audio particle system
        const particleSystem = new AudioParticleSystem();
        
        // Draw central audio source
        function drawAudioSource() {
            const time = Date.now() * 0.002;
            const pulse = Math.sin(time) * 0.3 + 0.7;
            const size = 10 * pulse;
            
            const gradient = ctx.createRadialGradient(
                canvas.width/2, canvas.height/2, 0,
                canvas.width/2, canvas.height/2, size * 3
            );
            
            gradient.addColorStop(0, 'rgba(255, 255, 255, 0.8)');
            gradient.addColorStop(0.3, 'rgba(100, 200, 255, 0.5)');
            gradient.addColorStop(1, 'rgba(100, 200, 255, 0)');
            
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(canvas.width/2, canvas.height/2, size, 0, Math.PI * 2);
            ctx.fill();
        }
        
        // Draw rhythm indicators
        function drawRhythmIndicators() {
            const time = Date.now() * 0.001;
            
            // Bass indicator
            const bassPulse = Math.sin(time * 0.5) > 0.8 ? 1.8 : 1;
            ctx.beginPath();
            ctx.arc(canvas.width/2 - 100, 50, 10 * bassPulse, 0, Math.PI * 2);
            ctx.fillStyle = `rgba(255, 50, 50, ${0.5 * bassPulse})`;
            ctx.fill();
            
            // Mid indicator
            const midPulse = Math.sin(time * 1.3) > 0.9 ? 1.6 : 1;
            ctx.beginPath();
            ctx.arc(canvas.width/2, 50, 8 * midPulse, 0, Math.PI * 2);
            ctx.fillStyle = `rgba(50, 255, 50, ${0.5 * midPulse})`;
            ctx.fill();
            
            // Treble indicator
            const treblePulse = Math.sin(time * 2.7) > 0.95 ? 1.4 : 1;
            ctx.beginPath();
            ctx.arc(canvas.width/2 + 100, 50, 6 * treblePulse, 0, Math.PI * 2);
            ctx.fillStyle = `rgba(50, 100, 255, ${0.5 * treblePulse})`;
            ctx.fill();
        }
        
        // Animation loop
        function animate() {
            // Clear with fade effect
            ctx.fillStyle = 'rgba(0, 5, 15, 0.1)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw rhythm indicators
            drawRhythmIndicators();
            
            // Draw central audio source
            drawAudioSource();
            
            // Update and draw particles
            particleSystem.update();
            particleSystem.draw();
            
            requestAnimationFrame(animate);
        }
        
        animate();
    </script>
</body>
</html>